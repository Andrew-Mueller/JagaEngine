package com.JagaEngine.animation;

import com.JagaEngine.util.ISubscriber;
import com.JagaEngine.util.PropertyInvoker;

import java.lang.reflect.InvocationTargetException;

/**
 * Implements an animation where the target value is a double value type.
 */
public class DoubleAnimation extends AnimationBase implements ISubscriber
{
    private long startTicks;

    private PropertyInvoker<Float> currentPosition;

    public DoubleAnimation(PropertyInvoker<Float> currentPosition, double targetValue, double seconds)
            throws IllegalAccessException, InvocationTargetException
    {
        startTicks = 0;

        this.startingTargetValue = currentPosition.getValue();
        this.endingTargetValue = (float)targetValue;

        this.currentPosition = currentPosition;

        // NOTE: why are we converting to float here...  seems like we are clamping to the resolution of the float data type.
        //
        this.speedValue = (double)((float)endingTargetValue - (float)this.currentPosition.getValue()) / (float)seconds;

        this.speedUnit = SpeedUnits.PIXELS;
        this.speedRate = SpeedRate.PER_SECOND;

        this.repeat = RepeatAnimation.ONCE;
        this.animate = true;

        // subscribe to the 'host' object's PAUSE and RESUME signals
        currentPosition.addSubscriber(this);

    }

    @Override
    public void animate() throws Exception
    {
        long intervalTicks;
        double delta = 0.0f;

        if (null == timer)
        {
            throw new Exception("timer has not yet been set.");
        }

        if (this.animate)
        {
            if (startTicks != 0)
            {

                intervalTicks = timer.getMilliseconds() - startTicks;

            }
            else
            {
                //PrecisionTimer.Instance().Stop();
                intervalTicks = 0;
            }

            // Calculate the proportion of speed since the last animation frame.
            // This translates to the number of pixels that will be moved this frame.
            delta = (double)(speedValue * (double)(intervalTicks / 1000D));

            try
            {
                // Ensure that the position does not exceed the target
                if ((float)java.lang.Math.abs((float) currentPosition.getValue() - (float)endingTargetValue) <= (float)java.lang.Math.abs(delta))
                {
                    delta = (double)((float)endingTargetValue - (float) currentPosition.getValue());

                    switch (repeat)
                    {

                        case FOREVER:
                        {
                            // there is a little glitch here because it will never actually reach the endValue
                            delta = (float)startingTargetValue - (float)currentPosition.getValue();
                            break;
                        }
                        case AUTOREVERSE:
                        {
                            float tempval = (float)endingTargetValue;
                            endingTargetValue = startingTargetValue;
                            startingTargetValue = tempval;
                            this.speedValue *= -1;
                            break;
                        }
                        case ONCE:
                        default:
                        {
                            this.animate = false;

                            onAnimationComplete();
                            break;
                        }
                    }
                }

                currentPosition.setValue((float)currentPosition.getValue() + (float)delta);
            }
            catch (Exception ex)
            {
                // TODO: i'm not sure what exception was being generated by calculating the double
                android.util.Log.e("DoubleAnimation", "Error calculating the new motion value", ex);
            }

            if (this.animate)
            {
                startTicks = timer.getMilliseconds();
            }
        }
    }

    @Override
    public void pause()
    {
        startTicks = 0;
    }

    @Override
    protected double getDistance()
    {
        return 0;
    }

    /**
     * Handle the specific signal sent by the signaler.
     *
     * @param signal Unique signal value received from the signaler to process.
     */
    @Override
    public void handle(int signal)
    {
        if (signal == signals.STOP_ANIMATION.ordinal())
        {
            this.animate = false;
        }
        else if (signal == signals.START_ANIMATION.ordinal())
        {
            this.animate = true;
        }
    }
}
